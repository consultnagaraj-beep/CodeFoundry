using System;
using System.Linq;
using System.Text;
using System.Globalization;
using System.Collections.Generic;
using System.IO;
using CodeFoundry.Generator.Tools;
using CodeFoundry.Generator.Models;

namespace CodeFoundry.Generator.Generators
{
    public static partial class StoredProcGenerator
    {
        // =========================================================
        // WRAPPER FOR PACKAGE GENERATION
        // =========================================================
        public static Dictionary<string, string> GenerateSpFiles(TableSchemaDto schema)
        {
            if (schema == null) throw new ArgumentNullException(nameof(schema));

            var sql = GenerateStoredProcFile(schema);

            var fileName = $"{schema.TableName}.SPs.sql";
            var relPath = Path.Combine("DAL", "StoredProcedures", fileName)
                              .Replace('\\', '/');

            return new Dictionary<string, string>
            {
                { relPath, sql }
            };
        }

        // =========================================================
        // CORE SQL GENERATION
        // =========================================================
        public static string GenerateStoredProcFile(TableSchemaDto schema)
        {
            if (schema == null) throw new ArgumentNullException(nameof(schema));

            var table = schema.TableName;
            var cols = schema.Columns ?? new List<ColumnSchema>();
            var pk = (schema.PrimaryKey != null && schema.PrimaryKey.Any())
                        ? schema.PrimaryKey
                        : (cols.Any() ? new List<string> { cols[0].ColumnName } : new List<string>());

            var sb = new StringBuilder();

            sb.AppendLine("-- ------------------------------------------------------------------------------");
            sb.AppendLine($"-- Stored Procedures for `{table}`");
            sb.AppendLine($"-- Generated by CodeFoundry at {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture)} UTC");
            sb.AppendLine("-- Contains:");
            sb.AppendLine("--   * Inline validation hooks for Insert / Update");
            sb.AppendLine("--   * Explicit DeleteValidate procedure");
            sb.AppendLine("--   * Insert, Update, Delete procedures");
            sb.AppendLine("-- ------------------------------------------------------------------------------");
            sb.AppendLine();

            // =========================================================
            // DELETE VALIDATION PROCEDURE (SINGLE SOURCE)
            // =========================================================
            sb.AppendLine($"DROP PROCEDURE IF EXISTS `{table}_DeleteValidate`;");
            sb.AppendLine("DELIMITER $$");
            sb.AppendLine($"CREATE PROCEDURE `{table}_DeleteValidate`(");

            var pkParams = pk.Select(k =>
            {
                var c = cols.FirstOrDefault(x => x.ColumnName == k);
                return $"IN p_{k} {SqlTypeForColumn(c)}";
            }).ToList();

            sb.AppendLine(string.Join(",\n    ", pkParams));
            sb.AppendLine(")");
            sb.AppendLine("BEGIN");
            sb.AppendLine();
            sb.AppendLine($"    -- << START CUSTOM {table}_DeleteValidate >>");
            sb.AppendLine("    -- Place delete-time validation here");
            sb.AppendLine("    -- Example:");
            sb.AppendLine("    -- IF EXISTS (SELECT 1 FROM OtherTable WHERE OtherTable.FK = p_Id) THEN");
            sb.AppendLine("    --   SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Delete blocked: referenced data exists';");
            sb.AppendLine("    -- END IF;");
            sb.AppendLine($"    -- << END CUSTOM {table}_DeleteValidate >>");
            sb.AppendLine();
            sb.AppendLine("END $$");
            sb.AppendLine("DELIMITER ;");
            sb.AppendLine();

            // =========================================================
            // INSERT / UPDATE / DELETE
            // =========================================================
            AppendProcedure(sb, schema, "Insert", cols, pk);
            AppendProcedure(sb, schema, "Update", cols, pk);
            AppendProcedure(sb, schema, "Delete", cols, pk, callDeleteValidate: true);

            return sb.ToString();
        }

        // =========================================================
        // PROCEDURE BUILDER
        // =========================================================
        private static void AppendProcedure(
            StringBuilder sb,
            TableSchemaDto schema,
            string op,
            List<ColumnSchema> cols,
            List<string> pk,
            bool callDeleteValidate = false)
        {
            var table = schema.TableName;
            var proc = $"{table}_{op}";

            sb.AppendLine($"DROP PROCEDURE IF EXISTS `{proc}`;");
            sb.AppendLine("DELIMITER $$");
            sb.AppendLine($"CREATE PROCEDURE `{proc}`(");

            var paramList = cols.Select(c =>
                $"IN p_{c.ColumnName} {SqlTypeForColumn(c)}").ToList();

            sb.AppendLine(string.Join(",\n    ", paramList));
            sb.AppendLine(")");
            sb.AppendLine("BEGIN");
            sb.AppendLine();

            // ---------------- VALIDATION HOOK ----------------
            sb.AppendLine($"    -- << START VALIDATION {proc} >>");
            sb.AppendLine($"    -- Add {op} validation logic here (NotEmpty / NoDuplicate / Custom)");
            sb.AppendLine($"    -- << END VALIDATION {proc} >>");
            sb.AppendLine();

            // ---------------- OPERATION ----------------
            if (op.Equals("Insert", StringComparison.OrdinalIgnoreCase))
            {
                sb.AppendLine($"    INSERT INTO `{table}`");
                sb.AppendLine($"    ({string.Join(", ", cols.Select(c => $"`{c.ColumnName}`"))})");
                sb.AppendLine($"    VALUES ({string.Join(", ", cols.Select(c => $"p_{c.ColumnName}"))});");

                var autoPk = cols.FirstOrDefault(c => c.IsPrimaryKey && c.IsAutoIncrement);
                if (autoPk != null)
                {
                    sb.AppendLine("    SELECT LAST_INSERT_ID() AS NewId;");
                }
            }
            else if (op.Equals("Update", StringComparison.OrdinalIgnoreCase))
            {
                var setCols = cols
                    .Where(c => !pk.Contains(c.ColumnName) && !c.IsAutoIncrement)
                    .Select(c => $"`{c.ColumnName}` = p_{c.ColumnName}")
                    .ToList();

                if (setCols.Any())
                {
                    sb.AppendLine($"    UPDATE `{table}`");
                    sb.AppendLine($"    SET {string.Join(", ", setCols)}");
                    sb.AppendLine($"    WHERE {BuildWhereClause(pk)};");
                }
            }
            else if (op.Equals("Delete", StringComparison.OrdinalIgnoreCase))
            {
                if (callDeleteValidate && pk.Any())
                {
                    sb.AppendLine($"    CALL `{table}_DeleteValidate`({string.Join(", ", pk.Select(k => "p_" + k))});");
                    sb.AppendLine();
                }

                sb.AppendLine($"    DELETE FROM `{table}`");
                sb.AppendLine($"    WHERE {BuildWhereClause(pk)};");
            }

            sb.AppendLine();
            sb.AppendLine("END $$");
            sb.AppendLine("DELIMITER ;");
            sb.AppendLine();
        }

        // =========================================================
        // HELPERS
        // =========================================================
        private static string BuildWhereClause(List<string> pk)
        {
            if (pk == null || pk.Count == 0)
                return "1=1 /* WARNING: no primary key */";

            return string.Join(" AND ", pk.Select(k => $"`{k}` = p_{k}"));
        }

        private static string SqlTypeForColumn(ColumnSchema c)
        {
            if (c == null) return "INT";

            var dt = (c.DataType ?? "").ToLowerInvariant();

            if (dt.Contains("char") || dt.Contains("text"))
            {
                return c.MaxLength.HasValue && c.MaxLength.Value > 0
                    ? $"VARCHAR({c.MaxLength.Value})"
                    : "TEXT";
            }

            if (dt.Contains("int")) return "INT";
            if (dt == "bigint") return "BIGINT";
            if (dt == "decimal" || dt == "numeric")
                return $"DECIMAL({c.NumericPrecision ?? 18},{c.NumericScale ?? 2})";
            if (dt == "float" || dt == "double") return dt.ToUpperInvariant();
            if (dt.Contains("date") || dt.Contains("time")) return "DATETIME";

            return "TEXT";
        }
    }
}
