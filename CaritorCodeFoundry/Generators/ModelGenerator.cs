using System;
using System.Linq;
using System.Text;
using CodeFoundry.Generator.Models;
using System.Globalization;

namespace CodeFoundry.Generator.Generators
{
    /// <summary>
    /// Generates a plain C# Model class (entity) from a TableSchemaDto.
    /// Rules:
    ///  - Class name: {TableName} (PascalCase)
    ///  - 1:1 mapping of columns -> auto-properties
    ///  - No DataAnnotations
    ///  - Nullable CLR types used for DB nullable columns (value types use ?)
    /// </summary>
    public static class ModelGenerator
    {
        /// <summary>
        /// Generate entity class text from table schema.
        /// </summary>
        /// <param name="schema">TableSchemaDto from SchemaReader</param>
        /// <param name="includeComments">Emit brief comment lines per property</param>
        /// <returns>String with full C# source file</returns>
        public static string GenerateModelTextFromSchema(TableSchemaDto schema, bool includeComments = true)
        {
            if (schema == null) throw new ArgumentNullException(nameof(schema));
            var className = ToPascal(schema.TableName);
            var sb = new StringBuilder();

            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine($"// Auto-generated by CodeFoundry (Model) at {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture)} UTC");
            sb.AppendLine("// One-to-one mapping with DB schema. No data annotations added.");
            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine();
            sb.AppendLine("namespace CodeFoundry.Generator.Models.Entities");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {className}");
            sb.AppendLine("    {");

            var cols = schema.Columns ?? Enumerable.Empty<ColumnSchema>();
            foreach (var c in cols)
            {
                if (includeComments)
                {
                    sb.AppendLine($"        // Column: {c.ColumnName}  DBType: {c.DataType}  Nullable: {c.IsNullable}  MaxLen: {c.MaxLength}");
                }

                var propName = ToPascal(c.ColumnName);
                var clrType = MapClrType(c.DataType, c.IsNullable);

                sb.AppendLine($"        public {clrType} {propName} {{ get; set; }}");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        #region Helpers

        private static string ToPascal(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            var parts = s.Split(new[] { '_', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            var res = string.Join("", parts.Select(p => char.ToUpperInvariant(p[0]) + (p.Length > 1 ? p.Substring(1) : "")));
            if (char.IsDigit(res[0])) res = "_" + res;
            return res;
        }

        private static bool IsDecimalType(string dbType)
        {
            if (string.IsNullOrEmpty(dbType)) return false;
            var dt = dbType.ToLowerInvariant();
            return dt == "decimal" || dt == "numeric" || dt == "float" || dt == "double";
        }

        /// <summary>
        /// Map common MySQL DB types to CLR types.
        /// Strings returned as 'string' always (no nullable marker).
        /// Value types use nullable T? if column is nullable.
        /// Note: this generator purposely keeps reference types as non-nullable strings
        /// (avoid nullable reference types to match project settings).
        /// </summary>
        private static string MapClrType(string dbType, bool isNullable)
        {
            if (string.IsNullOrEmpty(dbType)) return "string";
            var dt = dbType.ToLowerInvariant();

            string clr;
            if (dt.StartsWith("int") || dt == "mediumint" || dt == "smallint")
            {
                clr = "int";
            }
            else if (dt == "bigint")
            {
                clr = "long";
            }
            else if (dt == "tinyint(1)" || dt == "bit" || dt == "boolean")
            {
                clr = "bool";
            }
            else if (IsDecimalType(dt))
            {
                clr = "decimal";
            }
            else if (dt.StartsWith("date") || dt.StartsWith("timestamp") || dt.StartsWith("datetime"))
            {
                clr = "DateTime";
            }
            else
            {
                clr = "string";
            }

            // apply nullable marker for value types only
            if (clr != "string" && isNullable)
                return clr + "?";

            // keep strings as plain string (no nullable reference markers)
            return clr;
        }

        #endregion
    }
}
